"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateTerminalPrice = exports.calculateRepegCost = exports.calculateAdjustKCost = exports.getSwapDirection = exports.calculateSwapOutput = exports.calculateAmmReservesAfterSwap = exports.calculatePrice = void 0;
const anchor_1 = require("@project-serum/anchor");
const numericConstants_1 = require("../constants/numericConstants");
const position_1 = require("./position");
const types_1 = require("../types");
const assert_1 = require("../assert/assert");
const __1 = require("..");
/**
 * Calculates a price given an arbitrary base and quote amount (they must have the same precision)
 *
 * @param baseAssetAmount
 * @param quoteAssetAmount
 * @param peg_multiplier
 * @returns price : Precision MARK_PRICE_PRECISION
 */
function calculatePrice(baseAssetAmount, quoteAssetAmount, peg_multiplier) {
    if (baseAssetAmount.abs().lte(numericConstants_1.ZERO)) {
        return new anchor_1.BN(0);
    }
    return quoteAssetAmount
        .mul(numericConstants_1.MARK_PRICE_PRECISION)
        .mul(peg_multiplier)
        .div(numericConstants_1.PEG_PRECISION)
        .div(baseAssetAmount);
}
exports.calculatePrice = calculatePrice;
/**
 * Calculates what the amm reserves would be after swapping a quote or base asset amount.
 *
 * @param amm
 * @param inputAssetType
 * @param swapAmount
 * @param swapDirection
 * @returns quoteAssetReserve and baseAssetReserve after swap. : Precision AMM_RESERVE_PRECISION
 */
function calculateAmmReservesAfterSwap(amm, inputAssetType, swapAmount, swapDirection) {
    (0, assert_1.assert)(swapAmount.gte(numericConstants_1.ZERO), 'swapAmount must be greater than 0');
    let newQuoteAssetReserve;
    let newBaseAssetReserve;
    if (inputAssetType === 'quote') {
        swapAmount = swapAmount
            .mul(numericConstants_1.AMM_TIMES_PEG_TO_QUOTE_PRECISION_RATIO)
            .div(amm.pegMultiplier);
        [newQuoteAssetReserve, newBaseAssetReserve] = calculateSwapOutput(amm.quoteAssetReserve, swapAmount, swapDirection, amm.sqrtK.mul(amm.sqrtK));
    }
    else {
        [newBaseAssetReserve, newQuoteAssetReserve] = calculateSwapOutput(amm.baseAssetReserve, swapAmount, swapDirection, amm.sqrtK.mul(amm.sqrtK));
    }
    return [newQuoteAssetReserve, newBaseAssetReserve];
}
exports.calculateAmmReservesAfterSwap = calculateAmmReservesAfterSwap;
/**
 * Helper function calculating constant product curve output. Agnostic to whether input asset is quote or base
 *
 * @param inputAssetReserve
 * @param swapAmount
 * @param swapDirection
 * @param invariant
 * @returns newInputAssetReserve and newOutputAssetReserve after swap. : Precision AMM_RESERVE_PRECISION
 */
function calculateSwapOutput(inputAssetReserve, swapAmount, swapDirection, invariant) {
    let newInputAssetReserve;
    if (swapDirection === types_1.SwapDirection.ADD) {
        newInputAssetReserve = inputAssetReserve.add(swapAmount);
    }
    else {
        newInputAssetReserve = inputAssetReserve.sub(swapAmount);
    }
    const newOutputAssetReserve = invariant.div(newInputAssetReserve);
    return [newInputAssetReserve, newOutputAssetReserve];
}
exports.calculateSwapOutput = calculateSwapOutput;
/**
 * Translate long/shorting quote/base asset into amm operation
 *
 * @param inputAssetType
 * @param positionDirection
 */
function getSwapDirection(inputAssetType, positionDirection) {
    if (positionDirection === types_1.PositionDirection.LONG &&
        inputAssetType === 'base') {
        return types_1.SwapDirection.REMOVE;
    }
    if (positionDirection === types_1.PositionDirection.SHORT &&
        inputAssetType === 'quote') {
        return types_1.SwapDirection.REMOVE;
    }
    return types_1.SwapDirection.ADD;
}
exports.getSwapDirection = getSwapDirection;
/**
 * Helper function calculating adjust k cost
 * @param market
 * @param marketIndex
 * @param numerator
 * @param denomenator
 * @returns cost : Precision QUOTE_ASSET_PRECISION
 */
function calculateAdjustKCost(market, marketIndex, numerator, denomenator) {
    const netUserPosition = {
        baseAssetAmount: market.baseAssetAmount,
        lastCumulativeFundingRate: market.amm.cumulativeFundingRate,
        marketIndex: new anchor_1.BN(marketIndex),
        quoteAssetAmount: new anchor_1.BN(0),
    };
    const currentValue = (0, position_1.calculateBaseAssetValue)(market, netUserPosition);
    const marketNewK = Object.assign({}, market);
    marketNewK.amm = Object.assign({}, market.amm);
    marketNewK.amm.baseAssetReserve = market.amm.baseAssetReserve
        .mul(numerator)
        .div(denomenator);
    marketNewK.amm.quoteAssetReserve = market.amm.quoteAssetReserve
        .mul(numerator)
        .div(denomenator);
    marketNewK.amm.sqrtK = market.amm.sqrtK.mul(numerator).div(denomenator);
    netUserPosition.quoteAssetAmount = currentValue;
    const cost = (0, __1.calculatePositionPNL)(marketNewK, netUserPosition);
    return cost;
}
exports.calculateAdjustKCost = calculateAdjustKCost;
/**
 * Helper function calculating adjust pegMultiplier (repeg) cost
 *
 * @param market
 * @param marketIndex
 * @param newPeg
 * @returns cost : Precision QUOTE_ASSET_PRECISION
 */
function calculateRepegCost(market, marketIndex, newPeg) {
    const netUserPosition = {
        baseAssetAmount: market.baseAssetAmount,
        lastCumulativeFundingRate: market.amm.cumulativeFundingRate,
        marketIndex: new anchor_1.BN(marketIndex),
        quoteAssetAmount: new anchor_1.BN(0),
    };
    const currentValue = (0, position_1.calculateBaseAssetValue)(market, netUserPosition);
    netUserPosition.quoteAssetAmount = currentValue;
    const prevMarketPrice = (0, __1.calculateMarkPrice)(market);
    const marketNewPeg = Object.assign({}, market);
    marketNewPeg.amm = Object.assign({}, market.amm);
    // const marketNewPeg = JSON.parse(JSON.stringify(market));
    marketNewPeg.amm.pegMultiplier = newPeg;
    console.log('Price moves from', (0, __1.convertToNumber)(prevMarketPrice), 'to', (0, __1.convertToNumber)((0, __1.calculateMarkPrice)(marketNewPeg)));
    const cost = (0, __1.calculatePositionPNL)(marketNewPeg, netUserPosition);
    return cost;
}
exports.calculateRepegCost = calculateRepegCost;
/**
 * Helper function calculating terminal price of amm
 *
 * @param market
 * @returns cost : Precision MARK_PRICE_PRECISION
 */
function calculateTerminalPrice(market) {
    if (!market.initialized) {
        return new anchor_1.BN(0);
    }
    const directionToClose = market.baseAssetAmount.gt(numericConstants_1.ZERO)
        ? types_1.PositionDirection.SHORT
        : types_1.PositionDirection.LONG;
    const [newQuoteAssetReserve, newBaseAssetReserve] = calculateAmmReservesAfterSwap(market.amm, 'base', market.baseAssetAmount.abs(), getSwapDirection('base', directionToClose));
    const terminalPrice = newQuoteAssetReserve
        .mul(numericConstants_1.MARK_PRICE_PRECISION)
        .mul(market.amm.pegMultiplier)
        .div(numericConstants_1.PEG_PRECISION)
        .div(newBaseAssetReserve);
    return terminalPrice;
}
exports.calculateTerminalPrice = calculateTerminalPrice;
