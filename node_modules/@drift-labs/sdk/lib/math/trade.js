"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateTargetPriceTrade = exports.calculateTradeAcquiredAmounts = exports.calculateTradeSlippage = void 0;
const types_1 = require("../types");
const anchor_1 = require("@project-serum/anchor");
const assert_1 = require("../assert/assert");
const numericConstants_1 = require("../constants/numericConstants");
const market_1 = require("./market");
const amm_1 = require("./amm");
const utils_1 = require("./utils");
const MAXPCT = new anchor_1.BN(1000); //percentage units are [0,1000] => [0,1]
/**
 * Calculates avg/max slippage (price impact) for candidate trade
 * @param direction
 * @param amount
 * @param market
 * @return [pctAvgSlippage, pctMaxSlippage, entryPrice, newPrice]
 *
 * 'pctAvgSlippage' =>  the percentage change to entryPrice (average est slippage in execution) : Precision MARK_PRICE_PRECISION
 *
 * 'pctMaxSlippage' =>  the percentage change to maxPrice (highest est slippage in execution) : Precision MARK_PRICE_PRECISION
 *
 * 'entryPrice' => the average price of the trade : Precision MARK_PRICE_PRECISION
 *
 * 'newPrice' => the price of the asset after the trade : Precision MARK_PRICE_PRECISION
 */
function calculateTradeSlippage(direction, amount, market, inputAssetType = 'quote') {
    const oldPrice = (0, market_1.calculateMarkPrice)(market);
    if (amount.eq(numericConstants_1.ZERO)) {
        return [numericConstants_1.ZERO, numericConstants_1.ZERO, oldPrice, oldPrice];
    }
    const [acquiredBase, acquiredQuote] = calculateTradeAcquiredAmounts(direction, amount, market, inputAssetType);
    const entryPrice = (0, amm_1.calculatePrice)(acquiredBase, acquiredQuote, market.amm.pegMultiplier).mul(new anchor_1.BN(-1));
    const newPrice = (0, amm_1.calculatePrice)(market.amm.baseAssetReserve.sub(acquiredBase), market.amm.quoteAssetReserve.sub(acquiredQuote), market.amm.pegMultiplier);
    if (direction == types_1.PositionDirection.SHORT) {
        (0, assert_1.assert)(newPrice.lt(oldPrice));
    }
    else {
        (0, assert_1.assert)(oldPrice.lt(newPrice));
    }
    const pctMaxSlippage = newPrice
        .sub(oldPrice)
        .mul(numericConstants_1.MARK_PRICE_PRECISION)
        .div(oldPrice)
        .abs();
    const pctAvgSlippage = entryPrice
        .sub(oldPrice)
        .mul(numericConstants_1.MARK_PRICE_PRECISION)
        .div(oldPrice)
        .abs();
    return [pctAvgSlippage, pctMaxSlippage, entryPrice, newPrice];
}
exports.calculateTradeSlippage = calculateTradeSlippage;
/**
 * Calculates acquired amounts for trade executed
 * @param direction
 * @param amount
 * @param market
 * @return
 * 	| 'acquiredBase' =>  positive/negative change in user's base : BN TODO-PRECISION
 * 	| 'acquiredQuote' => positive/negative change in user's quote : BN TODO-PRECISION
 */
function calculateTradeAcquiredAmounts(direction, amount, market, inputAssetType = 'quote') {
    if (amount.eq(numericConstants_1.ZERO)) {
        return [numericConstants_1.ZERO, numericConstants_1.ZERO];
    }
    const [newQuoteAssetReserve, newBaseAssetReserve] = (0, amm_1.calculateAmmReservesAfterSwap)(market.amm, inputAssetType, amount, (0, amm_1.getSwapDirection)(inputAssetType, direction));
    const acquiredBase = market.amm.baseAssetReserve.sub(newBaseAssetReserve);
    const acquiredQuote = market.amm.quoteAssetReserve.sub(newQuoteAssetReserve);
    return [acquiredBase, acquiredQuote];
}
exports.calculateTradeAcquiredAmounts = calculateTradeAcquiredAmounts;
/**
 * calculateTargetPriceTrade
 * simple function for finding arbitraging trades
 * @param market
 * @param targetPrice
 * @param pct optional default is 100% gap filling, can set smaller.
 * @returns trade direction/size in order to push price to a targetPrice,
 *
 * [
 *   direction => direction of trade required, TODO-PRECISION
 *   tradeSize => size of trade required, TODO-PRECISION
 *   entryPrice => the entry price for the trade, TODO-PRECISION
 *   targetPrice => the target price TODO-PRECISION
 * ]
 */
function calculateTargetPriceTrade(market, targetPrice, pct = MAXPCT, outputAssetType = 'quote') {
    (0, assert_1.assert)(market.amm.baseAssetReserve.gt(numericConstants_1.ZERO));
    (0, assert_1.assert)(targetPrice.gt(numericConstants_1.ZERO));
    (0, assert_1.assert)(pct.lte(MAXPCT) && pct.gt(numericConstants_1.ZERO));
    const markPriceBefore = (0, market_1.calculateMarkPrice)(market);
    if (targetPrice.gt(markPriceBefore)) {
        const priceGap = targetPrice.sub(markPriceBefore);
        const priceGapScaled = priceGap.mul(pct).div(MAXPCT);
        targetPrice = markPriceBefore.add(priceGapScaled);
    }
    else {
        const priceGap = markPriceBefore.sub(targetPrice);
        const priceGapScaled = priceGap.mul(pct).div(MAXPCT);
        targetPrice = markPriceBefore.sub(priceGapScaled);
    }
    let direction;
    let tradeSize;
    let baseSize;
    const baseAssetReserveBefore = market.amm.baseAssetReserve;
    const quoteAssetReserveBefore = market.amm.quoteAssetReserve;
    const peg = market.amm.pegMultiplier;
    const invariant = market.amm.sqrtK.mul(market.amm.sqrtK);
    const k = invariant.mul(numericConstants_1.MARK_PRICE_PRECISION);
    let baseAssetReserveAfter;
    let quoteAssetReserveAfter;
    const biasModifier = new anchor_1.BN(1);
    let markPriceAfter;
    if (markPriceBefore.gt(targetPrice)) {
        // overestimate y2
        baseAssetReserveAfter = (0, utils_1.squareRootBN)(k.div(targetPrice).mul(peg).div(numericConstants_1.PEG_PRECISION).sub(biasModifier)).sub(new anchor_1.BN(1));
        quoteAssetReserveAfter = k
            .div(numericConstants_1.MARK_PRICE_PRECISION)
            .div(baseAssetReserveAfter);
        markPriceAfter = (0, amm_1.calculatePrice)(baseAssetReserveAfter, quoteAssetReserveAfter, peg);
        direction = types_1.PositionDirection.SHORT;
        tradeSize = quoteAssetReserveBefore
            .sub(quoteAssetReserveAfter)
            .mul(peg)
            .div(numericConstants_1.PEG_PRECISION)
            .div(numericConstants_1.AMM_TO_QUOTE_PRECISION_RATIO);
        baseSize = baseAssetReserveAfter.sub(baseAssetReserveBefore);
    }
    else if (markPriceBefore.lt(targetPrice)) {
        // underestimate y2
        baseAssetReserveAfter = (0, utils_1.squareRootBN)(k.div(targetPrice).mul(peg).div(numericConstants_1.PEG_PRECISION).add(biasModifier)).add(new anchor_1.BN(1));
        quoteAssetReserveAfter = k
            .div(numericConstants_1.MARK_PRICE_PRECISION)
            .div(baseAssetReserveAfter);
        markPriceAfter = (0, amm_1.calculatePrice)(baseAssetReserveAfter, quoteAssetReserveAfter, peg);
        direction = types_1.PositionDirection.LONG;
        tradeSize = quoteAssetReserveAfter
            .sub(quoteAssetReserveBefore)
            .mul(peg)
            .div(numericConstants_1.PEG_PRECISION)
            .div(numericConstants_1.AMM_TO_QUOTE_PRECISION_RATIO);
        baseSize = baseAssetReserveBefore.sub(baseAssetReserveAfter);
    }
    else {
        // no trade, market is at target
        direction = types_1.PositionDirection.LONG;
        tradeSize = numericConstants_1.ZERO;
        return [direction, tradeSize, targetPrice, targetPrice];
    }
    let tp1 = targetPrice;
    let tp2 = markPriceAfter;
    let originalDiff = targetPrice.sub(markPriceBefore);
    if (direction == types_1.PositionDirection.SHORT) {
        tp1 = markPriceAfter;
        tp2 = targetPrice;
        originalDiff = markPriceBefore.sub(targetPrice);
    }
    const entryPrice = tradeSize
        .mul(numericConstants_1.AMM_TO_QUOTE_PRECISION_RATIO)
        .mul(numericConstants_1.MARK_PRICE_PRECISION)
        .div(baseSize.abs());
    (0, assert_1.assert)(tp1.sub(tp2).lte(originalDiff), 'Target Price Calculation incorrect');
    (0, assert_1.assert)(tp2.lte(tp1) || tp2.sub(tp1).abs() < 100000, 'Target Price Calculation incorrect' +
        tp2.toString() +
        '>=' +
        tp1.toString() +
        'err: ' +
        tp2.sub(tp1).abs().toString());
    if (outputAssetType == 'quote') {
        return [direction, tradeSize, entryPrice, targetPrice];
    }
    else {
        return [direction, baseSize, entryPrice, targetPrice];
    }
}
exports.calculateTargetPriceTrade = calculateTargetPriceTrade;
