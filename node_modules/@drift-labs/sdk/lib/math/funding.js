"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.calculateFundingPool = exports.calculateLongShortFundingRateAndLiveTwaps = exports.calculateLongShortFundingRate = exports.calculateEstimatedFundingRate = exports.calculateAllEstimatedFundingRate = void 0;
const anchor_1 = require("@project-serum/anchor");
const numericConstants_1 = require("../constants/numericConstants");
const market_1 = require("./market");
/**
 *
 * @param market
 * @param pythClient
 * @param periodAdjustment
 * @returns Estimated funding rate. : Precision //TODO-PRECISION
 */
function calculateAllEstimatedFundingRate(market, oraclePriceData, periodAdjustment = new anchor_1.BN(1)) {
    return __awaiter(this, void 0, void 0, function* () {
        // periodAdjustment
        // 	1: hourly
        //  24: daily
        //  24 * 365.25: annualized
        const secondsInHour = new anchor_1.BN(3600);
        const hoursInDay = new anchor_1.BN(24);
        if (!market.initialized) {
            return [numericConstants_1.ZERO, numericConstants_1.ZERO, numericConstants_1.ZERO, numericConstants_1.ZERO, numericConstants_1.ZERO];
        }
        const payFreq = new anchor_1.BN(market.amm.fundingPeriod);
        // todo: sufficiently differs from blockchain timestamp?
        const now = new anchor_1.BN((Date.now() / 1000).toFixed(0));
        const timeSinceLastUpdate = now.sub(market.amm.lastFundingRateTs);
        // calculate real-time mark twap
        const lastMarkTwapWithMantissa = market.amm.lastMarkPriceTwap;
        const lastMarkPriceTwapTs = market.amm.lastMarkPriceTwapTs;
        const timeSinceLastMarkChange = now.sub(lastMarkPriceTwapTs);
        const markTwapTimeSinceLastUpdate = anchor_1.BN.max(secondsInHour, secondsInHour.sub(timeSinceLastMarkChange));
        const baseAssetPriceWithMantissa = (0, market_1.calculateMarkPrice)(market);
        const markTwapWithMantissa = markTwapTimeSinceLastUpdate
            .mul(lastMarkTwapWithMantissa)
            .add(timeSinceLastMarkChange.mul(baseAssetPriceWithMantissa))
            .div(timeSinceLastMarkChange.add(markTwapTimeSinceLastUpdate));
        // calculate real-time (predicted) oracle twap
        // note: oracle twap depends on `when the chord is struck` (market is trade)
        const lastOracleTwapWithMantissa = market.amm.lastOraclePriceTwap;
        const lastOraclePriceTwapTs = market.amm.lastOraclePriceTwapTs;
        const timeSinceLastOracleTwapUpdate = now.sub(lastOraclePriceTwapTs);
        const oracleTwapTimeSinceLastUpdate = anchor_1.BN.max(secondsInHour, secondsInHour.sub(timeSinceLastOracleTwapUpdate));
        // verify pyth input is positive for live update
        let oracleStablePriceNum = 0;
        let oracleInputCount = 0;
        if (oraclePriceData.price >= 0) {
            oracleStablePriceNum += oraclePriceData.price;
            oracleInputCount += 1;
        }
        if (oraclePriceData.previousPrice >= 0) {
            oracleStablePriceNum += oraclePriceData.previousPrice;
            oracleInputCount += 1;
        }
        oracleStablePriceNum = oracleStablePriceNum / oracleInputCount;
        const oraclePriceStableWithMantissa = new anchor_1.BN(oracleStablePriceNum * numericConstants_1.MARK_PRICE_PRECISION.toNumber());
        let oracleTwapWithMantissa = lastOracleTwapWithMantissa;
        const oracleLiveVsTwap = oraclePriceStableWithMantissa
            .sub(lastOracleTwapWithMantissa)
            .abs()
            .mul(numericConstants_1.MARK_PRICE_PRECISION)
            .mul(new anchor_1.BN(100))
            .div(lastOracleTwapWithMantissa);
        // verify pyth live input is within 10% of last twap for live update
        if (oracleLiveVsTwap.lte(numericConstants_1.MARK_PRICE_PRECISION.mul(new anchor_1.BN(10)))) {
            oracleTwapWithMantissa = oracleTwapTimeSinceLastUpdate
                .mul(lastOracleTwapWithMantissa)
                .add(timeSinceLastMarkChange.mul(oraclePriceStableWithMantissa))
                .div(timeSinceLastOracleTwapUpdate.add(oracleTwapTimeSinceLastUpdate));
        }
        const twapSpread = lastMarkTwapWithMantissa.sub(lastOracleTwapWithMantissa);
        const twapSpreadPct = twapSpread
            .mul(numericConstants_1.MARK_PRICE_PRECISION)
            .mul(new anchor_1.BN(100))
            .div(oracleTwapWithMantissa);
        const lowerboundEst = twapSpreadPct
            .mul(payFreq)
            .mul(anchor_1.BN.min(secondsInHour, timeSinceLastUpdate))
            .mul(periodAdjustment)
            .div(secondsInHour)
            .div(secondsInHour)
            .div(hoursInDay);
        const interpEst = twapSpreadPct.mul(periodAdjustment).div(hoursInDay);
        const interpRateQuote = twapSpreadPct
            .mul(periodAdjustment)
            .div(hoursInDay)
            .div(numericConstants_1.MARK_PRICE_PRECISION.div(numericConstants_1.QUOTE_PRECISION));
        let feePoolSize = calculateFundingPool(market);
        if (interpRateQuote.lt(new anchor_1.BN(0))) {
            feePoolSize = feePoolSize.mul(new anchor_1.BN(-1));
        }
        let cappedAltEst;
        let largerSide;
        let smallerSide;
        if (market.baseAssetAmountLong.gt(market.baseAssetAmountShort.abs())) {
            largerSide = market.baseAssetAmountLong.abs();
            smallerSide = market.baseAssetAmountShort.abs();
            if (twapSpread.gt(new anchor_1.BN(0))) {
                return [
                    markTwapWithMantissa,
                    oracleTwapWithMantissa,
                    lowerboundEst,
                    interpEst,
                    interpEst,
                ];
            }
        }
        else if (market.baseAssetAmountLong.lt(market.baseAssetAmountShort.abs())) {
            largerSide = market.baseAssetAmountShort.abs();
            smallerSide = market.baseAssetAmountLong.abs();
            if (twapSpread.lt(new anchor_1.BN(0))) {
                return [
                    markTwapWithMantissa,
                    oracleTwapWithMantissa,
                    lowerboundEst,
                    interpEst,
                    interpEst,
                ];
            }
        }
        else {
            return [
                markTwapWithMantissa,
                oracleTwapWithMantissa,
                lowerboundEst,
                interpEst,
                interpEst,
            ];
        }
        if (largerSide.gt(numericConstants_1.ZERO)) {
            // funding smaller flow
            cappedAltEst = smallerSide.mul(twapSpread).div(hoursInDay);
            const feePoolTopOff = feePoolSize
                .mul(numericConstants_1.MARK_PRICE_PRECISION.div(numericConstants_1.QUOTE_PRECISION))
                .mul(numericConstants_1.AMM_RESERVE_PRECISION);
            cappedAltEst = cappedAltEst.add(feePoolTopOff).div(largerSide);
            cappedAltEst = cappedAltEst
                .mul(numericConstants_1.MARK_PRICE_PRECISION)
                .mul(new anchor_1.BN(100))
                .div(oracleTwapWithMantissa)
                .mul(periodAdjustment);
            if (cappedAltEst.abs().gte(interpEst.abs())) {
                cappedAltEst = interpEst;
            }
        }
        else {
            cappedAltEst = interpEst;
        }
        return [
            markTwapWithMantissa,
            oracleTwapWithMantissa,
            lowerboundEst,
            cappedAltEst,
            interpEst,
        ];
    });
}
exports.calculateAllEstimatedFundingRate = calculateAllEstimatedFundingRate;
/**
 *
 * @param market
 * @param oraclePriceData
 * @param periodAdjustment
 * @param estimationMethod
 * @returns Estimated funding rate. : Precision //TODO-PRECISION
 */
function calculateEstimatedFundingRate(market, oraclePriceData, periodAdjustment = new anchor_1.BN(1), estimationMethod) {
    return __awaiter(this, void 0, void 0, function* () {
        const [_1, _2, lowerboundEst, cappedAltEst, interpEst] = yield calculateAllEstimatedFundingRate(market, oraclePriceData, periodAdjustment);
        if (estimationMethod == 'lowerbound') {
            //assuming remaining funding period has no gap
            return lowerboundEst;
        }
        else if (estimationMethod == 'capped') {
            return cappedAltEst;
        }
        else {
            return interpEst;
        }
    });
}
exports.calculateEstimatedFundingRate = calculateEstimatedFundingRate;
/**
 *
 * @param market
 * @param oraclePriceData
 * @param periodAdjustment
 * @returns Estimated funding rate. : Precision //TODO-PRECISION
 */
function calculateLongShortFundingRate(market, oraclePriceData, periodAdjustment = new anchor_1.BN(1)) {
    return __awaiter(this, void 0, void 0, function* () {
        const [_1, _2, _, cappedAltEst, interpEst] = yield calculateAllEstimatedFundingRate(market, oraclePriceData, periodAdjustment);
        if (market.baseAssetAmountLong.gt(market.baseAssetAmountShort)) {
            return [cappedAltEst, interpEst];
        }
        else if (market.baseAssetAmountLong.lt(market.baseAssetAmountShort)) {
            return [interpEst, cappedAltEst];
        }
        else {
            return [interpEst, interpEst];
        }
    });
}
exports.calculateLongShortFundingRate = calculateLongShortFundingRate;
/**
 *
 * @param market
 * @param oraclePriceData
 * @param periodAdjustment
 * @returns Estimated funding rate. : Precision //TODO-PRECISION
 */
function calculateLongShortFundingRateAndLiveTwaps(market, oraclePriceData, periodAdjustment = new anchor_1.BN(1)) {
    return __awaiter(this, void 0, void 0, function* () {
        const [markTwapLive, oracleTwapLive, _2, cappedAltEst, interpEst] = yield calculateAllEstimatedFundingRate(market, oraclePriceData, periodAdjustment);
        if (market.baseAssetAmountLong.gt(market.baseAssetAmountShort.abs())) {
            return [markTwapLive, oracleTwapLive, cappedAltEst, interpEst];
        }
        else if (market.baseAssetAmountLong.lt(market.baseAssetAmountShort.abs())) {
            return [markTwapLive, oracleTwapLive, interpEst, cappedAltEst];
        }
        else {
            return [markTwapLive, oracleTwapLive, interpEst, interpEst];
        }
    });
}
exports.calculateLongShortFundingRateAndLiveTwaps = calculateLongShortFundingRateAndLiveTwaps;
/**
 *
 * @param market
 * @returns Estimated fee pool size
 */
function calculateFundingPool(market) {
    // todo
    const totalFeeLB = market.amm.totalFee.div(new anchor_1.BN(2));
    const feePool = anchor_1.BN.max(numericConstants_1.ZERO, market.amm.totalFeeMinusDistributions
        .sub(totalFeeLB)
        .mul(new anchor_1.BN(2))
        .div(new anchor_1.BN(3)));
    return feePool;
}
exports.calculateFundingPool = calculateFundingPool;
