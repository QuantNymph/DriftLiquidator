"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClearingHouseUser = void 0;
const bn_js_1 = __importDefault(require("bn.js"));
const position_1 = require("./math/position");
const numericConstants_1 = require("./constants/numericConstants");
const defaultUserAccountSubscriber_1 = require("./accounts/defaultUserAccountSubscriber");
const _1 = require(".");
const addresses_1 = require("./addresses");
class ClearingHouseUser {
    constructor(clearingHouse, authority, accountSubscriber) {
        this.isSubscribed = false;
        this.clearingHouse = clearingHouse;
        this.authority = authority;
        this.accountSubscriber = accountSubscriber;
        this.eventEmitter = this.accountSubscriber.eventEmitter;
    }
    static from(clearingHouse, authority) {
        const accountSubscriber = new defaultUserAccountSubscriber_1.DefaultUserAccountSubscriber(clearingHouse.program, authority);
        return new ClearingHouseUser(clearingHouse, authority, accountSubscriber);
    }
    /**
     * Subscribe to ClearingHouseUser state accounts
     * @returns SusbcriptionSuccess result
     */
    subscribe() {
        return __awaiter(this, void 0, void 0, function* () {
            // Clearing house should already be subscribed, but await for the subscription just incase to avoid race condition
            yield this.clearingHouse.subscribe();
            this.isSubscribed = yield this.accountSubscriber.subscribe();
            return this.isSubscribed;
        });
    }
    /**
     *	Forces the accountSubscriber to fetch account updates from rpc
     */
    fetchAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.accountSubscriber.fetch();
        });
    }
    unsubscribe() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.accountSubscriber.unsubscribe();
            this.isSubscribed = false;
        });
    }
    getUserAccount() {
        return this.accountSubscriber.getUserAccount();
    }
    getUserPositionsAccount() {
        return this.accountSubscriber.getUserPositionsAccount();
    }
    /**
     * Gets the user's current position for a given market. If the user has no position returns undefined
     * @param marketIndex
     * @returns userPosition
     */
    getUserPosition(marketIndex) {
        return this.getUserPositionsAccount().positions.find((position) => position.marketIndex.eq(marketIndex));
    }
    getEmptyPosition(marketIndex) {
        return {
            baseAssetAmount: numericConstants_1.ZERO,
            lastCumulativeFundingRate: numericConstants_1.ZERO,
            marketIndex,
            quoteAssetAmount: numericConstants_1.ZERO,
        };
    }
    getUserAccountPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.userAccountPublicKey) {
                return this.userAccountPublicKey;
            }
            this.userAccountPublicKey = yield (0, addresses_1.getUserAccountPublicKey)(this.clearingHouse.program.programId, this.authority);
            return this.userAccountPublicKey;
        });
    }
    exists() {
        return __awaiter(this, void 0, void 0, function* () {
            const userAccountPublicKey = yield this.getUserAccountPublicKey();
            const userAccountRPCResponse = yield this.clearingHouse.connection.getParsedAccountInfo(userAccountPublicKey);
            return userAccountRPCResponse.value !== null;
        });
    }
    /**
     * calculates Buying Power = FC * MAX_LEVERAGE
     * @returns : Precision QUOTE_PRECISION
     */
    getBuyingPower() {
        return this.getFreeCollateral()
            .mul(this.getMaxLeverage('Initial'))
            .div(numericConstants_1.TEN_THOUSAND);
    }
    /**
     * calculates Free Collateral = (TC - TPV) * MAX_LEVERAGE
     * @returns : Precision QUOTE_PRECISION
     */
    getFreeCollateral() {
        return this.getTotalCollateral().sub(this.getTotalPositionValue()
            .mul(numericConstants_1.TEN_THOUSAND)
            .div(this.getMaxLeverage('Initial')));
    }
    /**
     * calculates unrealized position price pnl
     * @returns : Precision QUOTE_PRECISION
     */
    getUnrealizedPNL(withFunding, marketIndex) {
        return this.getUserPositionsAccount()
            .positions.filter((pos) => marketIndex ? pos.marketIndex === marketIndex : true)
            .reduce((pnl, marketPosition) => {
            const market = this.clearingHouse.getMarket(marketPosition.marketIndex);
            return pnl.add((0, _1.calculatePositionPNL)(market, marketPosition, withFunding));
        }, numericConstants_1.ZERO);
    }
    /**
     * calculates unrealized funding payment pnl
     * @returns : Precision QUOTE_PRECISION
     */
    getUnrealizedFundingPNL(marketIndex) {
        return this.getUserPositionsAccount()
            .positions.filter((pos) => marketIndex ? pos.marketIndex === marketIndex : true)
            .reduce((pnl, marketPosition) => {
            const market = this.clearingHouse.getMarket(marketPosition.marketIndex);
            return pnl.add((0, _1.calculatePositionFundingPNL)(market, marketPosition));
        }, numericConstants_1.ZERO);
    }
    /**
     * calculates TotalCollateral: collateral + unrealized pnl
     * @returns : Precision QUOTE_PRECISION
     */
    getTotalCollateral() {
        var _a;
        return ((_a = this.getUserAccount().collateral.add(this.getUnrealizedPNL(true))) !== null && _a !== void 0 ? _a : new bn_js_1.default(0));
    }
    /**
     * calculates sum of position value across all positions
     * @returns : Precision QUOTE_PRECISION
     */
    getTotalPositionValue() {
        return this.getUserPositionsAccount().positions.reduce((positionValue, marketPosition) => {
            const market = this.clearingHouse.getMarket(marketPosition.marketIndex);
            return positionValue.add((0, _1.calculateBaseAssetValue)(market, marketPosition));
        }, numericConstants_1.ZERO);
    }
    /**
     * calculates position value from closing 100%
     * @returns : Precision QUOTE_PRECISION
     */
    getPositionValue(marketIndex) {
        const userPosition = this.getUserPosition(marketIndex) || this.getEmptyPosition(marketIndex);
        const market = this.clearingHouse.getMarket(userPosition.marketIndex);
        return (0, _1.calculateBaseAssetValue)(market, userPosition);
    }
    getPositionSide(currentPosition) {
        if (currentPosition.baseAssetAmount.gt(numericConstants_1.ZERO)) {
            return _1.PositionDirection.LONG;
        }
        else if (currentPosition.baseAssetAmount.lt(numericConstants_1.ZERO)) {
            return _1.PositionDirection.SHORT;
        }
        else {
            return undefined;
        }
    }
    /**
     * calculates average exit price for closing 100% of position
     * @returns : Precision MARK_PRICE_PRECISION
     */
    getPositionEstimatedExitPriceAndPnl(position, amountToClose) {
        const market = this.clearingHouse.getMarket(position.marketIndex);
        const entryPrice = (0, position_1.calculateEntryPrice)(position);
        if (amountToClose) {
            if (amountToClose.eq(numericConstants_1.ZERO)) {
                return [(0, _1.calculateMarkPrice)(market), numericConstants_1.ZERO];
            }
            position = {
                baseAssetAmount: amountToClose,
                lastCumulativeFundingRate: position.lastCumulativeFundingRate,
                marketIndex: position.marketIndex,
                quoteAssetAmount: position.quoteAssetAmount,
            };
        }
        const baseAssetValue = (0, _1.calculateBaseAssetValue)(market, position);
        if (position.baseAssetAmount.eq(numericConstants_1.ZERO)) {
            return [numericConstants_1.ZERO, numericConstants_1.ZERO];
        }
        const exitPrice = baseAssetValue
            .mul(numericConstants_1.AMM_TO_QUOTE_PRECISION_RATIO)
            .mul(numericConstants_1.MARK_PRICE_PRECISION)
            .div(position.baseAssetAmount.abs());
        const pnlPerBase = exitPrice.sub(entryPrice);
        const pnl = pnlPerBase
            .mul(position.baseAssetAmount)
            .div(numericConstants_1.MARK_PRICE_PRECISION)
            .div(numericConstants_1.AMM_TO_QUOTE_PRECISION_RATIO);
        return [exitPrice, pnl];
    }
    /**
     * calculates current user leverage across all positions
     * @returns : Precision TEN_THOUSAND
     */
    getLeverage() {
        const totalCollateral = this.getTotalCollateral();
        const totalPositionValue = this.getTotalPositionValue();
        if (totalPositionValue.eq(numericConstants_1.ZERO) && totalCollateral.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.ZERO;
        }
        return totalPositionValue.mul(numericConstants_1.TEN_THOUSAND).div(totalCollateral);
    }
    /**
     * calculates max allowable leverage exceeding hitting requirement category
     * @params category {Initial, Partial, Maintenance}
     * @returns : Precision TEN_THOUSAND
     */
    getMaxLeverage(category) {
        const chState = this.clearingHouse.getStateAccount();
        let marginRatioCategory;
        switch (category) {
            case 'Initial':
                marginRatioCategory = chState.marginRatioInitial;
                break;
            case 'Maintenance':
                marginRatioCategory = chState.marginRatioMaintenance;
                break;
            case 'Partial':
                marginRatioCategory = chState.marginRatioPartial;
                break;
            default:
                marginRatioCategory = chState.marginRatioInitial;
                break;
        }
        const maxLeverage = numericConstants_1.TEN_THOUSAND.mul(numericConstants_1.TEN_THOUSAND).div(marginRatioCategory);
        return maxLeverage;
    }
    /**
     * calculates margin ratio: total collateral / |total position value|
     * @returns : Precision TEN_THOUSAND
     */
    getMarginRatio() {
        const totalPositionValue = this.getTotalPositionValue();
        if (totalPositionValue.eq(numericConstants_1.ZERO)) {
            return numericConstants_1.BN_MAX;
        }
        return this.getTotalCollateral().mul(numericConstants_1.TEN_THOUSAND).div(totalPositionValue);
    }
    canBeLiquidated() {
        const marginRatio = this.getMarginRatio();
        const canLiquidate = marginRatio.lte(numericConstants_1.PARTIAL_LIQUIDATION_RATIO);
        return [canLiquidate, marginRatio];
    }
    /**
     * Checks if any user position cumulative funding differs from respective market cumulative funding
     * @returns
     */
    needsToSettleFundingPayment() {
        const marketsAccount = this.clearingHouse.getMarketsAccount();
        for (const userPosition of this.getUserPositionsAccount().positions) {
            if (userPosition.baseAssetAmount.eq(numericConstants_1.ZERO)) {
                continue;
            }
            const market = marketsAccount.markets[userPosition.marketIndex.toNumber()];
            if (market.amm.cumulativeFundingRateLong.eq(userPosition.lastCumulativeFundingRate) ||
                market.amm.cumulativeFundingRateShort.eq(userPosition.lastCumulativeFundingRate)) {
                continue;
            }
            return true;
        }
        return false;
    }
    /**
     * Calculate the liquidation price of a position, with optional parameter to calculate the liquidation price after a trade
     * @param targetMarket
     * @param positionBaseSizeChange // change in position size to calculate liquidation price for : Precision 10^13
     * @param partial
     * @returns Precision : MARK_PRICE_PRECISION
     */
    liquidationPriceOld(targetMarket, positionBaseSizeChange = numericConstants_1.ZERO, partial = false) {
        // +/-(margin_ratio-liq_ratio) * price_now = price_liq
        // todo: margin_ratio is not symmetric on price action (both numer and denom change)
        // margin_ratio = collateral / base_asset_value
        /* example: assume BTC price is $40k (examine 10% up/down)
        
        if 10k deposit and levered 10x short BTC => BTC up $400 means:
        1. higher base_asset_value (+$4k)
        2. lower collateral (-$4k)
        3. (10k - 4k)/(100k + 4k) => 6k/104k => .0576

        for 10x long, BTC down $400:
        3. (10k - 4k) / (100k - 4k) = 6k/96k => .0625 */
        const currentPrice = (0, _1.calculateMarkPrice)(this.clearingHouse.getMarket(targetMarket.marketIndex));
        const totalCollateralUSDC = this.getTotalCollateral();
        // calculate the total position value ignoring any value from the target market of the trade
        const totalCurrentPositionValueIgnoringTargetUSDC = this.getTotalPositionValueExcludingMarket(targetMarket.marketIndex);
        const currentMarketPosition = this.getUserPosition(targetMarket.marketIndex) ||
            this.getEmptyPosition(targetMarket.marketIndex);
        const currentMarketPositionBaseSize = currentMarketPosition.baseAssetAmount;
        // calculate position for current market after trade
        const proposedMarketPosition = {
            marketIndex: targetMarket.marketIndex,
            baseAssetAmount: currentMarketPositionBaseSize.add(positionBaseSizeChange),
            lastCumulativeFundingRate: new bn_js_1.default(0),
            quoteAssetAmount: new bn_js_1.default(0),
        };
        const market = this.clearingHouse.getMarket(proposedMarketPosition.marketIndex);
        const proposedMarketPositionValueUSDC = (0, _1.calculateBaseAssetValue)(market, proposedMarketPosition);
        // total position value after trade
        const targetTotalPositionValueUSDC = totalCurrentPositionValueIgnoringTargetUSDC.add(proposedMarketPositionValueUSDC);
        let totalFreeCollateralUSDC = this.getTotalCollateral().sub(this.getTotalPositionValue()
            .mul(numericConstants_1.TEN_THOUSAND)
            .div(this.getMaxLeverage('Maintenance')));
        if (partial) {
            totalFreeCollateralUSDC = this.getTotalCollateral().sub(this.getTotalPositionValue()
                .mul(numericConstants_1.TEN_THOUSAND)
                .div(this.getMaxLeverage('Partial')));
        }
        // if the position value after the trade is less than total collateral, there is no liq price
        if (targetTotalPositionValueUSDC.lte(totalFreeCollateralUSDC) &&
            proposedMarketPosition.baseAssetAmount.gt(numericConstants_1.ZERO)) {
            return new bn_js_1.default(-1);
        }
        // get current margin ratio based on current collateral and proposed total position value
        let marginRatio;
        if (proposedMarketPositionValueUSDC.eq(numericConstants_1.ZERO)) {
            marginRatio = numericConstants_1.BN_MAX;
        }
        else {
            marginRatio = totalCollateralUSDC
                .mul(numericConstants_1.TEN_THOUSAND)
                .div(proposedMarketPositionValueUSDC);
        }
        let liqRatio = numericConstants_1.FULL_LIQUIDATION_RATIO;
        if (partial) {
            liqRatio = numericConstants_1.PARTIAL_LIQUIDATION_RATIO;
        }
        // sign of position in current market after the trade
        const baseAssetSignIsNeg = proposedMarketPosition.baseAssetAmount.isNeg();
        let pctChange = marginRatio.abs().sub(liqRatio);
        // if user is short, higher price is liq
        if (baseAssetSignIsNeg) {
            pctChange = pctChange.add(numericConstants_1.TEN_THOUSAND);
        }
        else {
            if (numericConstants_1.TEN_THOUSAND.lte(pctChange)) {
                // no liquidation price, position is a fully/over collateralized long
                // handle as NaN on UI
                return new bn_js_1.default(-1);
            }
            pctChange = numericConstants_1.TEN_THOUSAND.sub(pctChange);
        }
        const liqPrice = currentPrice.mul(pctChange).div(numericConstants_1.TEN_THOUSAND);
        return liqPrice;
    }
    /**
     * Calculate the liquidation price of a position, with optional parameter to calculate the liquidation price after a trade
     * @param targetMarket
     * @param positionBaseSizeChange // change in position size to calculate liquidation price for : Precision 10^13
     * @param partial
     * @returns Precision : MARK_PRICE_PRECISION
     */
    liquidationPrice(targetMarket, positionBaseSizeChange = numericConstants_1.ZERO, partial = false) {
        // solves formula for example calc below
        /* example: assume BTC price is $40k (examine 10% up/down)
            
            if 10k deposit and levered 10x short BTC => BTC up $400 means:
            1. higher base_asset_value (+$4k)
            2. lower collateral (-$4k)
            3. (10k - 4k)/(100k + 4k) => 6k/104k => .0576
    
            for 10x long, BTC down $400:
            3. (10k - 4k) / (100k - 4k) = 6k/96k => .0625 */
        const tc = this.getTotalCollateral();
        const tpv = this.getTotalPositionValue();
        const partialLev = 16;
        const maintLev = 20;
        const thisLev = partial ? new bn_js_1.default(partialLev) : new bn_js_1.default(maintLev);
        // calculate the total position value ignoring any value from the target market of the trade
        const totalCurrentPositionValueIgnoringTargetUSDC = this.getTotalPositionValueExcludingMarket(targetMarket.marketIndex);
        const currentMarketPosition = this.getUserPosition(targetMarket.marketIndex) ||
            this.getEmptyPosition(targetMarket.marketIndex);
        const currentMarketPositionBaseSize = currentMarketPosition.baseAssetAmount;
        const proposedBaseAssetAmount = currentMarketPositionBaseSize.add(positionBaseSizeChange);
        // calculate position for current market after trade
        const proposedMarketPosition = {
            marketIndex: targetMarket.marketIndex,
            baseAssetAmount: proposedBaseAssetAmount,
            lastCumulativeFundingRate: currentMarketPosition.lastCumulativeFundingRate,
            quoteAssetAmount: new bn_js_1.default(0),
        };
        const market = this.clearingHouse.getMarket(proposedMarketPosition.marketIndex);
        const proposedMarketPositionValueUSDC = (0, _1.calculateBaseAssetValue)(market, proposedMarketPosition);
        // total position value after trade
        const targetTotalPositionValueUSDC = totalCurrentPositionValueIgnoringTargetUSDC.add(proposedMarketPositionValueUSDC);
        let totalFreeCollateralUSDC = tc.sub(totalCurrentPositionValueIgnoringTargetUSDC
            .mul(numericConstants_1.TEN_THOUSAND)
            .div(this.getMaxLeverage('Maintenance')));
        if (partial) {
            totalFreeCollateralUSDC = tc.sub(totalCurrentPositionValueIgnoringTargetUSDC
                .mul(numericConstants_1.TEN_THOUSAND)
                .div(this.getMaxLeverage('Partial')));
        }
        let priceDelt;
        if (proposedBaseAssetAmount.lt(numericConstants_1.ZERO)) {
            priceDelt = tc
                .mul(thisLev)
                .sub(tpv)
                .mul(numericConstants_1.PRICE_TO_QUOTE_PRECISION)
                .div(thisLev.add(new bn_js_1.default(1)));
        }
        else {
            priceDelt = tc
                .mul(thisLev)
                .sub(tpv)
                .mul(numericConstants_1.PRICE_TO_QUOTE_PRECISION)
                .div(thisLev.sub(new bn_js_1.default(1)));
        }
        let currentPrice;
        if (positionBaseSizeChange.eq(numericConstants_1.ZERO)) {
            currentPrice = (0, _1.calculateMarkPrice)(this.clearingHouse.getMarket(targetMarket.marketIndex));
        }
        else {
            const direction = positionBaseSizeChange.gt(numericConstants_1.ZERO)
                ? _1.PositionDirection.LONG
                : _1.PositionDirection.SHORT;
            currentPrice = (0, _1.calculateTradeSlippage)(direction, positionBaseSizeChange.abs(), this.clearingHouse.getMarket(targetMarket.marketIndex), 'base')[3]; // newPrice after swap
        }
        // if the position value after the trade is less than total collateral, there is no liq price
        if (targetTotalPositionValueUSDC.lte(totalFreeCollateralUSDC) &&
            proposedMarketPosition.baseAssetAmount.gt(numericConstants_1.ZERO)) {
            return new bn_js_1.default(-1);
        }
        if (proposedBaseAssetAmount.eq(numericConstants_1.ZERO))
            return new bn_js_1.default(-1);
        const eatMargin2 = priceDelt
            .mul(numericConstants_1.AMM_RESERVE_PRECISION)
            .div(proposedBaseAssetAmount);
        if (eatMargin2.gt(currentPrice)) {
            return new bn_js_1.default(-1);
        }
        const liqPrice = currentPrice.sub(eatMargin2);
        return liqPrice;
    }
    /**
     * Calculates the estimated liquidation price for a position after closing a quote amount of the position.
     * @param positionMarketIndex
     * @param closeQuoteAmount
     * @returns : Precision MARK_PRICE_PRECISION
     */
    liquidationPriceAfterClose(positionMarketIndex, closeQuoteAmount) {
        const currentPosition = this.getUserPosition(positionMarketIndex) ||
            this.getEmptyPosition(positionMarketIndex);
        const closeBaseAmount = currentPosition.baseAssetAmount
            .mul(closeQuoteAmount)
            .div(currentPosition.quoteAssetAmount)
            .add(currentPosition.baseAssetAmount
            .mul(closeQuoteAmount)
            .mod(currentPosition.quoteAssetAmount))
            .neg();
        return this.liquidationPrice({
            marketIndex: positionMarketIndex,
        }, closeBaseAmount);
    }
    /**
     * Get the maximum trade size for a given market, taking into account the user's current leverage, positions, collateral, etc.
     *
     * To Calculate Max Quote Available:
     *
     * Case 1: SameSide
     * 	=> Remaining quote to get to maxLeverage
     *
     * Case 2: NOT SameSide && currentLeverage <= maxLeverage
     * 	=> Current opposite position x2 + remaining to get to maxLeverage
     *
     * Case 3: NOT SameSide && currentLeverage > maxLeverage && otherPositions - currentPosition > maxLeverage
     * 	=> strictly reduce current position size
     *
     * Case 4: NOT SameSide && currentLeverage > maxLeverage && otherPositions - currentPosition < maxLeverage
     * 	=> current position + remaining to get to maxLeverage
     *
     * @param marketIndex
     * @param tradeSide
     * @param userMaxLeverageSetting - leverage : Precision TEN_THOUSAND
     * @returns tradeSizeAllowed : Precision QUOTE_PRECISION
     */
    getMaxTradeSizeUSDC(targetMarketIndex, tradeSide, userMaxLeverageSetting) {
        const currentPosition = this.getUserPosition(targetMarketIndex) ||
            this.getEmptyPosition(targetMarketIndex);
        const targetSide = tradeSide === _1.PositionDirection.SHORT ? 'short' : 'long';
        const currentPositionSide = (currentPosition === null || currentPosition === void 0 ? void 0 : currentPosition.baseAssetAmount.isNeg())
            ? 'short'
            : 'long';
        const targettingSameSide = !currentPosition
            ? true
            : targetSide === currentPositionSide;
        // add any position we have on the opposite side of the current trade, because we can "flip" the size of this position without taking any extra leverage.
        const oppositeSizeValueUSDC = targettingSameSide
            ? numericConstants_1.ZERO
            : this.getPositionValue(targetMarketIndex);
        // get current leverage
        const currentLeverage = this.getLeverage();
        const remainingLeverage = bn_js_1.default.max(userMaxLeverageSetting.sub(currentLeverage), numericConstants_1.ZERO);
        // get total collateral
        const totalCollateral = this.getTotalCollateral();
        // position side allowed based purely on current leverage
        let maxPositionSize = remainingLeverage
            .mul(totalCollateral)
            .div(numericConstants_1.TEN_THOUSAND);
        if (userMaxLeverageSetting.sub(currentLeverage).gte(numericConstants_1.ZERO)) {
            if (oppositeSizeValueUSDC.eq(numericConstants_1.ZERO)) {
                // case 1 : Regular trade where current total position less than max, and no opposite position to account for
                // do nothing
            }
            else {
                // case 2 : trade where current total position less than max, but need to account for flipping the current position over to the other side
                maxPositionSize = maxPositionSize.add(oppositeSizeValueUSDC.mul(new bn_js_1.default(2)));
            }
        }
        else {
            // current leverage is greater than max leverage - can only reduce position size
            if (!targettingSameSide) {
                const currentPositionQuoteSize = this.getPositionValue(targetMarketIndex);
                const currentTotalQuoteSize = currentLeverage
                    .mul(totalCollateral)
                    .div(numericConstants_1.TEN_THOUSAND);
                const otherPositionsTotalQuoteSize = currentTotalQuoteSize.sub(currentPositionQuoteSize);
                const quoteValueOfMaxLeverage = userMaxLeverageSetting
                    .mul(totalCollateral)
                    .div(numericConstants_1.TEN_THOUSAND);
                if (otherPositionsTotalQuoteSize
                    .sub(currentPositionQuoteSize)
                    .gte(quoteValueOfMaxLeverage)) {
                    // case 3: Can only reduce the current position because it will still be greater than max leverage
                    maxPositionSize = currentPositionQuoteSize;
                }
                else {
                    // case 4: Can reduce the position, and then take extra remaining quote to get to max leverage
                    const allowedQuoteSizeAfterClosingCurrentPosition = quoteValueOfMaxLeverage.sub(otherPositionsTotalQuoteSize);
                    maxPositionSize = currentPositionQuoteSize.add(allowedQuoteSizeAfterClosingCurrentPosition);
                }
            }
            else {
                // do nothing if targetting same side
            }
        }
        // subtract oneMillionth of maxPositionSize
        // => to avoid rounding errors when taking max leverage
        const oneMilli = maxPositionSize.div(numericConstants_1.QUOTE_PRECISION);
        return maxPositionSize.sub(oneMilli);
    }
    // TODO - should this take the price impact of the trade into account for strict accuracy?
    /**
     * Returns the leverage ratio for the account after adding (or subtracting) the given quote size to the given position
     * @param targetMarketIndex
     * @param positionMarketIndex
     * @param tradeQuoteAmount
     * @returns leverageRatio : Precision TEN_THOUSAND
     */
    accountLeverageRatioAfterTrade(targetMarketIndex, tradeQuoteAmount, tradeSide) {
        const currentPosition = this.getUserPosition(targetMarketIndex) ||
            this.getEmptyPosition(targetMarketIndex);
        let currentPositionQuoteAmount = this.getPositionValue(targetMarketIndex);
        const currentSide = currentPosition && currentPosition.baseAssetAmount.isNeg()
            ? _1.PositionDirection.SHORT
            : _1.PositionDirection.LONG;
        if (currentSide === _1.PositionDirection.SHORT)
            currentPositionQuoteAmount = currentPositionQuoteAmount.neg();
        if (tradeSide === _1.PositionDirection.SHORT)
            tradeQuoteAmount = tradeQuoteAmount.neg();
        const currentMarketPositionAfterTrade = currentPositionQuoteAmount
            .add(tradeQuoteAmount)
            .abs();
        const totalPositionAfterTradeExcludingTargetMarket = this.getTotalPositionValueExcludingMarket(targetMarketIndex);
        const totalCollateral = this.getTotalCollateral();
        if (totalCollateral.gt(numericConstants_1.ZERO)) {
            const newLeverage = currentMarketPositionAfterTrade
                .add(totalPositionAfterTradeExcludingTargetMarket)
                .abs()
                .mul(numericConstants_1.TEN_THOUSAND)
                .div(totalCollateral);
            return newLeverage;
        }
        else {
            return new bn_js_1.default(0);
        }
    }
    /**
     * Calculates how much fee will be taken for a given sized trade
     * @param quoteAmount
     * @returns feeForQuote : Precision QUOTE_PRECISION
     */
    calculateFeeForQuoteAmount(quoteAmount) {
        const feeStructure = this.clearingHouse.getStateAccount().feeStructure;
        return quoteAmount
            .mul(feeStructure.feeNumerator)
            .div(feeStructure.feeDenominator);
    }
    /**
     * Get the total position value, excluding any position coming from the given target market
     * @param marketToIgnore
     * @returns positionValue : Precision QUOTE_PRECISION
     */
    getTotalPositionValueExcludingMarket(marketToIgnore) {
        const currentMarketPosition = this.getUserPosition(marketToIgnore) ||
            this.getEmptyPosition(marketToIgnore);
        let currentMarketPositionValueUSDC = numericConstants_1.ZERO;
        if (currentMarketPosition) {
            currentMarketPositionValueUSDC = this.getPositionValue(marketToIgnore);
        }
        return this.getTotalPositionValue().sub(currentMarketPositionValueUSDC);
    }
}
exports.ClearingHouseUser = ClearingHouseUser;
