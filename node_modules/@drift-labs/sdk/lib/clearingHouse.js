"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.ClearingHouse = void 0;
const anchor_1 = require("@project-serum/anchor");
const spl_token_1 = require("@solana/spl-token");
const anchor = __importStar(require("@project-serum/anchor"));
const clearing_house_json_1 = __importDefault(require("./idl/clearing_house.json"));
const web3_js_1 = require("@solana/web3.js");
const addresses_1 = require("./addresses");
const defaultClearingHouseAccountSubscriber_1 = require("./accounts/defaultClearingHouseAccountSubscriber");
const defaultTxSender_1 = require("./tx/defaultTxSender");
const utils_1 = require("./tx/utils");
/**
 * # ClearingHouse
 * This class is the main way to interact with Drift Protocol. It allows you to subscribe to the various accounts where the Market's state is stored, as well as: opening positions, liquidating, settling funding, depositing & withdrawing, and more.
 *
 * The default way to construct a ClearingHouse instance is using the {@link from} method. This will create an instance using the static {@link DefaultClearingHouseAccountSubscriber}, which will use a websocket for each state account subscription.
 * Alternatively, if you want to implement your own method of subscribing to the state accounts on the blockchain, you can implement a {@link ClearingHouseAccountSubscriber} and use it in the {@link ClearingHouse.constructor}
 */
class ClearingHouse {
    constructor(connection, wallet, program, accountSubscriber, txSender, opts) {
        this.isSubscribed = false;
        this.connection = connection;
        this.wallet = wallet;
        this.opts = opts;
        this.program = program;
        this.accountSubscriber = accountSubscriber;
        this.eventEmitter = this.accountSubscriber.eventEmitter;
        this.txSender = txSender;
    }
    static from(connection, wallet, clearingHouseProgramId, opts = anchor_1.Provider.defaultOptions()) {
        const provider = new anchor_1.Provider(connection, wallet, opts);
        const program = new anchor_1.Program(clearing_house_json_1.default, clearingHouseProgramId, provider);
        const accountSubscriber = new defaultClearingHouseAccountSubscriber_1.DefaultClearingHouseAccountSubscriber(program);
        const txSender = new defaultTxSender_1.DefaultTxSender(provider);
        return new ClearingHouse(connection, wallet, program, accountSubscriber, txSender, opts);
    }
    /**
     *
     * @param optionalSubscriptions - Optional extra accounts to subcribe to. Always subscribes to base clearing house state and market account state by default. You should only subscribe to optional extra accounts if required, to avoid overloading your RPC.
     * @returns Promise<boolean> : SubscriptionSuccess
     */
    subscribe(optionalSubscriptions) {
        return __awaiter(this, void 0, void 0, function* () {
            this.isSubscribed = yield this.accountSubscriber.subscribe(optionalSubscriptions);
            return this.isSubscribed;
        });
    }
    /**
     * Shorthand function to subscribe to all available Clearing House State Accounts
     * @returns Promise<boolean> : SubscriptionSuccess
     */
    subscribeToAll() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.subscribe([
                'curveHistoryAccount',
                'depositHistoryAccount',
                'fundingPaymentHistoryAccount',
                'fundingRateHistoryAccount',
                'liquidationHistoryAccount',
                'tradeHistoryAccount',
            ]);
        });
    }
    /**
     *	Forces the accountSubscriber to fetch account updates from rpc
     */
    fetchAccounts() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.accountSubscriber.fetch();
        });
    }
    /**
     * Unsubscribe from all currently subscribed state accounts
     */
    unsubscribe() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.accountSubscriber.unsubscribe();
            this.isSubscribed = false;
        });
    }
    getStatePublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.statePublicKey) {
                return this.statePublicKey;
            }
            this.statePublicKey = yield (0, addresses_1.getClearingHouseStateAccountPublicKey)(this.program.programId);
            return this.statePublicKey;
        });
    }
    getStateAccount() {
        return this.accountSubscriber.getStateAccount();
    }
    getMarketsAccount() {
        return this.accountSubscriber.getMarketsAccount();
    }
    getMarket(marketIndex) {
        if (marketIndex instanceof anchor_1.BN) {
            marketIndex = marketIndex.toNumber();
        }
        return this.getMarketsAccount().markets[marketIndex];
    }
    getFundingPaymentHistoryAccount() {
        return this.accountSubscriber.getFundingPaymentHistoryAccount();
    }
    getFundingRateHistoryAccount() {
        return this.accountSubscriber.getFundingRateHistoryAccount();
    }
    getTradeHistoryAccount() {
        return this.accountSubscriber.getTradeHistoryAccount();
    }
    getLiquidationHistoryAccount() {
        return this.accountSubscriber.getLiquidationHistoryAccount();
    }
    getDepositHistoryAccount() {
        return this.accountSubscriber.getDepositHistoryAccount();
    }
    getCurveHistoryAccount() {
        return this.accountSubscriber.getCurveHistoryAccount();
    }
    /**
     * Update the wallet to use for clearing house transactions and linked user account
     * @param newWallet
     */
    updateWallet(newWallet) {
        const newProvider = new anchor_1.Provider(this.connection, newWallet, this.opts);
        const newProgram = new anchor_1.Program(clearing_house_json_1.default, this.program.programId, newProvider);
        const newTxSender = new defaultTxSender_1.DefaultTxSender(newProvider);
        this.wallet = newWallet;
        this.provider = newProvider;
        this.program = newProgram;
        this.txSender = newTxSender;
        this.userAccountPublicKey = undefined;
        this.userAccount = undefined;
    }
    initializeUserAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            const [userPositionsAccount, userAccountPublicKey, initializeUserAccountIx,] = yield this.getInitializeUserInstructions();
            const tx = new web3_js_1.Transaction().add(initializeUserAccountIx);
            const txSig = yield this.txSender.send(tx, [userPositionsAccount], this.opts);
            return [txSig, userAccountPublicKey];
        });
    }
    getInitializeUserInstructions() {
        return __awaiter(this, void 0, void 0, function* () {
            const [userPublicKey, userAccountNonce] = yield (0, addresses_1.getUserAccountPublicKeyAndNonce)(this.program.programId, this.wallet.publicKey);
            const remainingAccounts = [];
            const optionalAccounts = {
                whitelistToken: false,
            };
            const state = this.getStateAccount();
            if (state.whitelistMint) {
                optionalAccounts.whitelistToken = true;
                const associatedTokenPublicKey = yield spl_token_1.Token.getAssociatedTokenAddress(spl_token_1.ASSOCIATED_TOKEN_PROGRAM_ID, spl_token_1.TOKEN_PROGRAM_ID, state.whitelistMint, this.wallet.publicKey);
                remainingAccounts.push({
                    pubkey: associatedTokenPublicKey,
                    isWritable: false,
                    isSigner: false,
                });
            }
            const userPositions = new web3_js_1.Keypair();
            const initializeUserAccountIx = yield this.program.instruction.initializeUser(userAccountNonce, optionalAccounts, {
                accounts: {
                    user: userPublicKey,
                    authority: this.wallet.publicKey,
                    rent: anchor.web3.SYSVAR_RENT_PUBKEY,
                    systemProgram: anchor.web3.SystemProgram.programId,
                    userPositions: userPositions.publicKey,
                    state: yield this.getStatePublicKey(),
                },
                remainingAccounts: remainingAccounts,
            });
            return [userPositions, userPublicKey, initializeUserAccountIx];
        });
    }
    /**
     * Get the address for the Clearing House User's account. NOT the user's wallet address.
     * @returns
     */
    getUserAccountPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.userAccountPublicKey) {
                return this.userAccountPublicKey;
            }
            this.userAccountPublicKey = yield (0, addresses_1.getUserAccountPublicKey)(this.program.programId, this.wallet.publicKey);
            return this.userAccountPublicKey;
        });
    }
    getUserAccount() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.userAccount) {
                return this.userAccount;
            }
            this.userAccount = (yield this.program.account.user.fetch(yield this.getUserAccountPublicKey()));
            return this.userAccount;
        });
    }
    depositCollateral(amount, collateralAccountPublicKey, userPositionsAccountPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const depositCollateralIx = yield this.getDepositCollateralInstruction(amount, collateralAccountPublicKey, userPositionsAccountPublicKey);
            const tx = new web3_js_1.Transaction().add(depositCollateralIx);
            return yield this.txSender.send(tx);
        });
    }
    getDepositCollateralInstruction(amount, collateralAccountPublicKey, userPositionsAccountPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const userAccountPublicKey = yield this.getUserAccountPublicKey();
            if (!userPositionsAccountPublicKey) {
                userPositionsAccountPublicKey = (yield this.getUserAccount()).positions;
            }
            const state = this.getStateAccount();
            return yield this.program.instruction.depositCollateral(amount, {
                accounts: {
                    state: yield this.getStatePublicKey(),
                    user: userAccountPublicKey,
                    collateralVault: state.collateralVault,
                    userCollateralAccount: collateralAccountPublicKey,
                    authority: this.wallet.publicKey,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                    markets: state.markets,
                    fundingPaymentHistory: state.fundingPaymentHistory,
                    depositHistory: state.depositHistory,
                    userPositions: userPositionsAccountPublicKey,
                },
            });
        });
    }
    /**
     * Creates the Clearing House User account for a user, and deposits some initial collateral
     * @param amount
     * @param collateralAccountPublicKey
     * @returns
     */
    initializeUserAccountAndDepositCollateral(amount, collateralAccountPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const [userPositionsAccount, userAccountPublicKey, initializeUserAccountIx,] = yield this.getInitializeUserInstructions();
            const depositCollateralIx = yield this.getDepositCollateralInstruction(amount, collateralAccountPublicKey, userPositionsAccount.publicKey);
            const tx = new web3_js_1.Transaction()
                .add(initializeUserAccountIx)
                .add(depositCollateralIx);
            const txSig = yield this.program.provider.send(tx, [userPositionsAccount]);
            return [txSig, userAccountPublicKey];
        });
    }
    initializeUserAccountForDevnet(mockUSDCFaucet, amount) {
        return __awaiter(this, void 0, void 0, function* () {
            const [associateTokenPublicKey, createAssociatedAccountIx, mintToIx] = yield mockUSDCFaucet.createAssociatedTokenAccountAndMintToInstructions(this.wallet.publicKey, amount);
            const [userPositionsAccount, userAccountPublicKey, initializeUserAccountIx,] = yield this.getInitializeUserInstructions();
            const depositCollateralIx = yield this.getDepositCollateralInstruction(amount, associateTokenPublicKey, userPositionsAccount.publicKey);
            const tx = new web3_js_1.Transaction()
                .add(createAssociatedAccountIx)
                .add(mintToIx)
                .add(initializeUserAccountIx)
                .add(depositCollateralIx);
            const txSig = yield this.program.provider.send(tx, [userPositionsAccount]);
            return [txSig, userAccountPublicKey];
        });
    }
    deleteUser() {
        return __awaiter(this, void 0, void 0, function* () {
            const userAccountPublicKey = yield this.getUserAccountPublicKey();
            const user = yield this.program.account.user.fetch(userAccountPublicKey);
            const deleteUserTx = yield this.program.transaction.deleteUser({
                accounts: {
                    user: userAccountPublicKey,
                    userPositions: user.positions,
                    authority: this.wallet.publicKey,
                },
            });
            return this.txSender.send(deleteUserTx, [], this.opts);
        });
    }
    withdrawCollateral(amount, collateralAccountPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.txSender.send((0, utils_1.wrapInTx)(yield this.getWithdrawCollateralIx(amount, collateralAccountPublicKey)), [], this.opts);
        });
    }
    getWithdrawCollateralIx(amount, collateralAccountPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const userAccountPublicKey = yield this.getUserAccountPublicKey();
            const user = yield this.program.account.user.fetch(userAccountPublicKey);
            const state = this.getStateAccount();
            return yield this.program.instruction.withdrawCollateral(amount, {
                accounts: {
                    state: yield this.getStatePublicKey(),
                    user: userAccountPublicKey,
                    collateralVault: state.collateralVault,
                    collateralVaultAuthority: state.collateralVaultAuthority,
                    insuranceVault: state.insuranceVault,
                    insuranceVaultAuthority: state.insuranceVaultAuthority,
                    userCollateralAccount: collateralAccountPublicKey,
                    authority: this.wallet.publicKey,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                    markets: state.markets,
                    userPositions: user.positions,
                    fundingPaymentHistory: state.fundingPaymentHistory,
                    depositHistory: state.depositHistory,
                },
            });
        });
    }
    openPosition(direction, amount, marketIndex, limitPrice, discountToken, referrer) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.txSender.send((0, utils_1.wrapInTx)(yield this.getOpenPositionIx(direction, amount, marketIndex, limitPrice, discountToken, referrer)), [], this.opts);
        });
    }
    getOpenPositionIx(direction, amount, marketIndex, limitPrice, discountToken, referrer) {
        return __awaiter(this, void 0, void 0, function* () {
            const userAccountPublicKey = yield this.getUserAccountPublicKey();
            const userAccount = yield this.getUserAccount();
            if (limitPrice == undefined) {
                limitPrice = new anchor_1.BN(0); // no limit
            }
            const optionalAccounts = {
                discountToken: false,
                referrer: false,
            };
            const remainingAccounts = [];
            if (discountToken) {
                optionalAccounts.discountToken = true;
                remainingAccounts.push({
                    pubkey: discountToken,
                    isWritable: false,
                    isSigner: false,
                });
            }
            if (referrer) {
                optionalAccounts.referrer = true;
                remainingAccounts.push({
                    pubkey: referrer,
                    isWritable: true,
                    isSigner: false,
                });
            }
            const priceOracle = this.getMarketsAccount().markets[marketIndex.toNumber()].amm.oracle;
            const state = this.getStateAccount();
            return yield this.program.instruction.openPosition(direction, amount, marketIndex, limitPrice, optionalAccounts, {
                accounts: {
                    state: yield this.getStatePublicKey(),
                    user: userAccountPublicKey,
                    authority: this.wallet.publicKey,
                    markets: state.markets,
                    userPositions: userAccount.positions,
                    tradeHistory: state.tradeHistory,
                    fundingPaymentHistory: state.fundingPaymentHistory,
                    fundingRateHistory: state.fundingRateHistory,
                    oracle: priceOracle,
                },
                remainingAccounts: remainingAccounts,
            });
        });
    }
    /**
     * Close an entire position. If you want to reduce a position, use the {@link openPosition} method in the opposite direction of the current position.
     * @param marketIndex
     * @param discountToken
     * @param referrer
     * @returns
     */
    closePosition(marketIndex, discountToken, referrer) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield this.txSender.send((0, utils_1.wrapInTx)(yield this.getClosePositionIx(marketIndex, discountToken, referrer)), [], this.opts);
        });
    }
    getClosePositionIx(marketIndex, discountToken, referrer) {
        return __awaiter(this, void 0, void 0, function* () {
            const userAccountPublicKey = yield this.getUserAccountPublicKey();
            const userAccount = yield this.getUserAccount();
            const priceOracle = this.getMarketsAccount().markets[marketIndex.toNumber()].amm.oracle;
            const optionalAccounts = {
                discountToken: false,
                referrer: false,
            };
            const remainingAccounts = [];
            if (discountToken) {
                optionalAccounts.discountToken = true;
                remainingAccounts.push({
                    pubkey: discountToken,
                    isWritable: false,
                    isSigner: false,
                });
            }
            if (referrer) {
                optionalAccounts.referrer = true;
                remainingAccounts.push({
                    pubkey: referrer,
                    isWritable: true,
                    isSigner: false,
                });
            }
            const state = this.getStateAccount();
            return yield this.program.instruction.closePosition(marketIndex, optionalAccounts, {
                accounts: {
                    state: yield this.getStatePublicKey(),
                    user: userAccountPublicKey,
                    authority: this.wallet.publicKey,
                    markets: state.markets,
                    userPositions: userAccount.positions,
                    tradeHistory: state.tradeHistory,
                    fundingPaymentHistory: state.fundingPaymentHistory,
                    fundingRateHistory: state.fundingRateHistory,
                    oracle: priceOracle,
                },
                remainingAccounts: remainingAccounts,
            });
        });
    }
    liquidate(liquidateeUserAccountPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.txSender.send((0, utils_1.wrapInTx)(yield this.getLiquidateIx(liquidateeUserAccountPublicKey)), [], this.opts);
        });
    }
    getLiquidateIx(liquidateeUserAccountPublicKey) {
        return __awaiter(this, void 0, void 0, function* () {
            const userAccountPublicKey = yield this.getUserAccountPublicKey();
            const liquidateeUserAccount = yield this.program.account.user.fetch(liquidateeUserAccountPublicKey);
            const liquidateePositions = yield this.program.account.userPositions.fetch(liquidateeUserAccount.positions);
            const markets = this.getMarketsAccount();
            const remainingAccounts = [];
            for (const position of liquidateePositions.positions) {
                if (!position.baseAssetAmount.eq(new anchor_1.BN(0))) {
                    const market = markets.markets[position.marketIndex.toNumber()];
                    remainingAccounts.push({
                        pubkey: market.amm.oracle,
                        isWritable: false,
                        isSigner: false,
                    });
                }
            }
            const state = this.getStateAccount();
            return yield this.program.instruction.liquidate({
                accounts: {
                    state: yield this.getStatePublicKey(),
                    authority: this.wallet.publicKey,
                    user: liquidateeUserAccountPublicKey,
                    liquidator: userAccountPublicKey,
                    collateralVault: state.collateralVault,
                    collateralVaultAuthority: state.collateralVaultAuthority,
                    insuranceVault: state.insuranceVault,
                    insuranceVaultAuthority: state.insuranceVaultAuthority,
                    tokenProgram: spl_token_1.TOKEN_PROGRAM_ID,
                    markets: state.markets,
                    userPositions: liquidateeUserAccount.positions,
                    tradeHistory: state.tradeHistory,
                    liquidationHistory: state.liquidationHistory,
                    fundingPaymentHistory: state.fundingPaymentHistory,
                },
                remainingAccounts: remainingAccounts,
            });
        });
    }
    updateFundingRate(oracle, marketIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.txSender.send((0, utils_1.wrapInTx)(yield this.getUpdateFundingRateIx(oracle, marketIndex)), [], this.opts);
        });
    }
    getUpdateFundingRateIx(oracle, marketIndex) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.getStateAccount();
            return yield this.program.instruction.updateFundingRate(marketIndex, {
                accounts: {
                    state: yield this.getStatePublicKey(),
                    markets: state.markets,
                    oracle: oracle,
                    fundingRateHistory: state.fundingRateHistory,
                },
            });
        });
    }
    settleFundingPayment(userAccount, userPositionsAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.txSender.send((0, utils_1.wrapInTx)(yield this.getSettleFundingPaymentIx(userAccount, userPositionsAccount)), [], this.opts);
        });
    }
    getSettleFundingPaymentIx(userAccount, userPositionsAccount) {
        return __awaiter(this, void 0, void 0, function* () {
            const state = this.getStateAccount();
            return yield this.program.instruction.settleFundingPayment({
                accounts: {
                    state: yield this.getStatePublicKey(),
                    markets: state.markets,
                    user: userAccount,
                    userPositions: userPositionsAccount,
                    fundingPaymentHistory: state.fundingPaymentHistory,
                },
            });
        });
    }
    triggerEvent(eventName, data) {
        this.eventEmitter.emit(eventName, data);
    }
}
exports.ClearingHouse = ClearingHouse;
