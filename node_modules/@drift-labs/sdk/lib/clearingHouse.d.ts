/// <reference types="node" />
/// <reference types="bn.js" />
import { BN, Program, Provider } from '@project-serum/anchor';
import { MarketsAccount, StateAccount, DepositHistoryAccount, FundingPaymentHistoryAccount, FundingRateHistoryAccount, IWallet, LiquidationHistoryAccount, PositionDirection, TradeHistoryAccount, UserAccount, Market, ExtendedCurveHistoryAccount } from './types';
import { Connection, PublicKey, TransactionSignature, Keypair, ConfirmOptions, TransactionInstruction } from '@solana/web3.js';
import { MockUSDCFaucet } from './mockUSDCFaucet';
import { EventEmitter } from 'events';
import StrictEventEmitter from 'strict-event-emitter-types';
import { ClearingHouseAccountSubscriber, ClearingHouseAccountEvents, ClearingHouseAccountTypes } from './accounts/types';
import { TxSender } from './tx/types';
/**
 * # ClearingHouse
 * This class is the main way to interact with Drift Protocol. It allows you to subscribe to the various accounts where the Market's state is stored, as well as: opening positions, liquidating, settling funding, depositing & withdrawing, and more.
 *
 * The default way to construct a ClearingHouse instance is using the {@link from} method. This will create an instance using the static {@link DefaultClearingHouseAccountSubscriber}, which will use a websocket for each state account subscription.
 * Alternatively, if you want to implement your own method of subscribing to the state accounts on the blockchain, you can implement a {@link ClearingHouseAccountSubscriber} and use it in the {@link ClearingHouse.constructor}
 */
export declare class ClearingHouse {
    connection: Connection;
    wallet: IWallet;
    program: Program;
    provider: Provider;
    opts?: ConfirmOptions;
    accountSubscriber: ClearingHouseAccountSubscriber;
    eventEmitter: StrictEventEmitter<EventEmitter, ClearingHouseAccountEvents>;
    isSubscribed: boolean;
    txSender: TxSender;
    static from(connection: Connection, wallet: IWallet, clearingHouseProgramId: PublicKey, opts?: ConfirmOptions): ClearingHouse;
    constructor(connection: Connection, wallet: IWallet, program: Program, accountSubscriber: ClearingHouseAccountSubscriber, txSender: TxSender, opts: ConfirmOptions);
    /**
     *
     * @param optionalSubscriptions - Optional extra accounts to subcribe to. Always subscribes to base clearing house state and market account state by default. You should only subscribe to optional extra accounts if required, to avoid overloading your RPC.
     * @returns Promise<boolean> : SubscriptionSuccess
     */
    subscribe(optionalSubscriptions?: ClearingHouseAccountTypes[]): Promise<boolean>;
    /**
     * Shorthand function to subscribe to all available Clearing House State Accounts
     * @returns Promise<boolean> : SubscriptionSuccess
     */
    subscribeToAll(): Promise<boolean>;
    /**
     *	Forces the accountSubscriber to fetch account updates from rpc
     */
    fetchAccounts(): Promise<void>;
    /**
     * Unsubscribe from all currently subscribed state accounts
     */
    unsubscribe(): Promise<void>;
    statePublicKey?: PublicKey;
    getStatePublicKey(): Promise<PublicKey>;
    getStateAccount(): StateAccount;
    getMarketsAccount(): MarketsAccount;
    getMarket(marketIndex: BN | number): Market;
    getFundingPaymentHistoryAccount(): FundingPaymentHistoryAccount;
    getFundingRateHistoryAccount(): FundingRateHistoryAccount;
    getTradeHistoryAccount(): TradeHistoryAccount;
    getLiquidationHistoryAccount(): LiquidationHistoryAccount;
    getDepositHistoryAccount(): DepositHistoryAccount;
    getCurveHistoryAccount(): ExtendedCurveHistoryAccount;
    /**
     * Update the wallet to use for clearing house transactions and linked user account
     * @param newWallet
     */
    updateWallet(newWallet: IWallet): void;
    initializeUserAccount(): Promise<[
        TransactionSignature,
        PublicKey
    ]>;
    getInitializeUserInstructions(): Promise<[
        Keypair,
        PublicKey,
        TransactionInstruction
    ]>;
    userAccountPublicKey?: PublicKey;
    /**
     * Get the address for the Clearing House User's account. NOT the user's wallet address.
     * @returns
     */
    getUserAccountPublicKey(): Promise<PublicKey>;
    userAccount?: UserAccount;
    getUserAccount(): Promise<UserAccount>;
    depositCollateral(amount: BN, collateralAccountPublicKey: PublicKey, userPositionsAccountPublicKey?: PublicKey): Promise<TransactionSignature>;
    getDepositCollateralInstruction(amount: BN, collateralAccountPublicKey: PublicKey, userPositionsAccountPublicKey?: PublicKey): Promise<TransactionInstruction>;
    /**
     * Creates the Clearing House User account for a user, and deposits some initial collateral
     * @param amount
     * @param collateralAccountPublicKey
     * @returns
     */
    initializeUserAccountAndDepositCollateral(amount: BN, collateralAccountPublicKey: PublicKey): Promise<[TransactionSignature, PublicKey]>;
    initializeUserAccountForDevnet(mockUSDCFaucet: MockUSDCFaucet, amount: BN): Promise<[TransactionSignature, PublicKey]>;
    deleteUser(): Promise<TransactionSignature>;
    withdrawCollateral(amount: BN, collateralAccountPublicKey: PublicKey): Promise<TransactionSignature>;
    getWithdrawCollateralIx(amount: BN, collateralAccountPublicKey: PublicKey): Promise<TransactionInstruction>;
    openPosition(direction: PositionDirection, amount: BN, marketIndex: BN, limitPrice?: BN, discountToken?: PublicKey, referrer?: PublicKey): Promise<TransactionSignature>;
    getOpenPositionIx(direction: PositionDirection, amount: BN, marketIndex: BN, limitPrice?: BN, discountToken?: PublicKey, referrer?: PublicKey): Promise<TransactionInstruction>;
    /**
     * Close an entire position. If you want to reduce a position, use the {@link openPosition} method in the opposite direction of the current position.
     * @param marketIndex
     * @param discountToken
     * @param referrer
     * @returns
     */
    closePosition(marketIndex: BN, discountToken?: PublicKey, referrer?: PublicKey): Promise<TransactionSignature>;
    getClosePositionIx(marketIndex: BN, discountToken?: PublicKey, referrer?: PublicKey): Promise<TransactionInstruction>;
    liquidate(liquidateeUserAccountPublicKey: PublicKey): Promise<TransactionSignature>;
    getLiquidateIx(liquidateeUserAccountPublicKey: PublicKey): Promise<TransactionInstruction>;
    updateFundingRate(oracle: PublicKey, marketIndex: BN): Promise<TransactionSignature>;
    getUpdateFundingRateIx(oracle: PublicKey, marketIndex: BN): Promise<TransactionInstruction>;
    settleFundingPayment(userAccount: PublicKey, userPositionsAccount: PublicKey): Promise<TransactionSignature>;
    getSettleFundingPaymentIx(userAccount: PublicKey, userPositionsAccount: PublicKey): Promise<TransactionInstruction>;
    triggerEvent(eventName: keyof ClearingHouseAccountEvents, data?: any): void;
}
//# sourceMappingURL=clearingHouse.d.ts.map